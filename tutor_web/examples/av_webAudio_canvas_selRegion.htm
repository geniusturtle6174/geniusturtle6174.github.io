<!DOCTYPE html><html><head>	<style>		a:hover {			background-color: #ff9		}	</style></head><body bgcolor="#ccccff"><canvas id="myCanvas" width="1000" height="200" style="border:1px solid;position:absolute;top:30px;left:50px;"></canvas><table style="border:1px solid;position:absolute;top:250px;left:50px;padding:5px">	<tr>		<td>			<p>				<audio id="myAudio" src="" controls></audio>			</p>			<p>				檢視比例:&nbsp;&nbsp;(-) <input type="range" value="1000" min="500" max="4000" step="50" onchange="redrawWave(this.value)"> (+)			</p>			<p>				<input type="button" value="播放選取區間" onclick="playSelectedRegion()">			</p>			<p>				<input type="button" value="顯示選取區間(秒)" onclick="showSelectedRegionInfo()">				<span id="showTime"></span>			</p>			<p>				<input type="button" value="指定選取區間(秒)" onclick="assignRegion()">:				<input id="assignSelectMin" type="number" min=0 max=1 step=0.01> ~				<input id="assignSelectMax" type="number" min=0 max=1 step=0.01>			</p>		</td>		<td>			<span id="showLyrics"></span>		</td>	</tr></table><script>// Ref: https://stackoverflow.com/questions/22073716/create-a-waveform-of-the-full-track-with-web-audio-api// Audio variablesAudioContext = window.AudioContext || window.webkitAudioContext;audioCtx = new AudioContext();currentBuffer  = null;myAudio = document.getElementById("myAudio");downSampleRate = 400;// Canvas variablescanvas = document.getElementById("myCanvas");canvasCtx = canvas.getContext("2d");// Update-needed variablescanvasWidth = document.getElementById("myCanvas").width;canvasHeight = document.getElementById("myCanvas").height;regionBegin = regionEnd = regionDragging = false;timer = null;boundaryNearBy = null;function loadMusic(url){	var req = new XMLHttpRequest();	req.open("GET", url, true);	req.responseType = "arraybuffer";		req.onreadystatechange = function(e){		if(req.readyState == 4){			if(req.status == 200){				audioCtx.decodeAudioData(req.response, function(buffer){					currentBuffer = buffer;					displayBuffer(buffer.getChannelData(0)); // Draw left channel only					myAudio.src = url;					document.getElementById("assignSelectMin").max = currentBuffer.duration;					document.getElementById("assignSelectMax").max = currentBuffer.duration;				}, function (){					alert('Error while decoding your file.');				});			}			else {				alert('Error during the load. Wrong url or cross origin issue.');			}		}	};	req.send();}function canvasXToSec(x){	return x / canvasWidth * currentBuffer.duration;}function secToCanvasX(sec){	return sec / currentBuffer.duration * canvasWidth;}function sampleIdxToCanvasX(sampleIdx, sigLen){	return Math.floor( canvasWidth * sampleIdx / sigLen);}function drawVertoclaLineAtX(x){	canvasCtx.lineWidth = 1;	canvasCtx.beginPath();	canvasCtx.strokeStyle = "#000";	canvasCtx.moveTo(x, 0);	canvasCtx.lineTo(x, canvasHeight);	canvasCtx.stroke();}function drawRectAtXRange(x1, x2){	canvasCtx.fillStyle = "rgba(255,204,255,0.3)";	canvasCtx.fillRect(Math.min(x1, x2), 0, Math.abs(x1-x2), canvasHeight);}function drawSelectedRegion(x1, x2){	drawRectAtXRange(x1, x2);	drawVertoclaLineAtX(x1);	drawVertoclaLineAtX(x2);}function displayBuffer(sig){	canvasWidth = document.getElementById("myCanvas").width;	canvasHeight = document.getElementById("myCanvas").height;	canvasCtx.fillStyle = '#fff';	canvasCtx.fillRect(0, 0, canvasWidth, canvasHeight);	canvasCtx.strokeStyle = '#000';	canvasCtx.lineWidth = 1;	for (var i=0; i<sig.length; i+=downSampleRate) {		var x = sampleIdxToCanvasX(i, sig.length);		var y = sig[i] * canvasHeight / 2 + canvasHeight / 2;		canvasCtx.beginPath();		canvasCtx.moveTo(x, canvasHeight / 2);		canvasCtx.lineTo(x, y);		canvasCtx.stroke();	}}function redrawWave(width){	if(currentBuffer == null){		return false	}	// Save selected region (unit: sec)	s1 = canvasXToSec(regionBegin);	s2 = canvasXToSec(regionEnd);	// Update canvas width and wavform	document.getElementById("myCanvas").width = width;	displayBuffer(currentBuffer.getChannelData(0));	// Draw new selected region	regionBegin = secToCanvasX(s1);	regionEnd = secToCanvasX(s2);	drawSelectedRegion(regionBegin, regionEnd);}canvas.onmousedown = function(ev){	if(canvas.style.cursor == 'col-resize'){ // Adjust old region		mx = event.clientX - parseInt(canvas.style.left) + window.pageXOffset;		if(boundaryNearBy == 'begin'){			regionBegin = regionEnd;		}		console.log("Begin adjusting region:", regionBegin, mx);	}	else { // A new region		regionBegin = event.clientX - parseInt(canvas.style.left) + window.pageXOffset;		console.log("Begin new region:", regionBegin, canvasXToSec(regionBegin));	}	regionDragging = true;}canvas.onmousemove = function(){	mx = event.clientX - parseInt(canvas.style.left) + window.pageXOffset;	if(regionDragging){		displayBuffer(currentBuffer.getChannelData(0));		drawSelectedRegion(regionBegin, mx);	}	else {		if(Math.abs(mx-regionBegin) <= 1 || Math.abs(mx-regionEnd) <= 1){			canvas.style.cursor = 'col-resize';			if(Math.abs(mx-regionBegin) <= 1){				boundaryNearBy = 'begin';			}		}		else if(Math.abs(mx-regionBegin) > 3 && Math.abs(mx-regionEnd) > 3) {			canvas.style.cursor = 'default';			boundaryNearBy = null;		}	}}canvas.onmouseup = function(ev){	regionEnd = event.clientX - parseInt(canvas.style.left) + window.pageXOffset;	console.log("End:", regionEnd, canvasXToSec(regionEnd));	console.log("---------------");	regionDragging = false;	canvas.style.cursor = 'default';}function playSelectedRegion(){	t1 = Math.min(canvasXToSec(regionBegin), canvasXToSec(regionEnd));	t2 = Math.max(canvasXToSec(regionBegin), canvasXToSec(regionEnd));	playBetween(t1, t2);}function showSelectedRegionInfo(){	t1 = Math.min(canvasXToSec(regionBegin), canvasXToSec(regionEnd));	t2 = Math.max(canvasXToSec(regionBegin), canvasXToSec(regionEnd));	document.getElementById("showTime").innerHTML = t1 + ', ' + t2;}function assignRegion(){	t1 = Math.min(document.getElementById("assignSelectMin").value, document.getElementById("assignSelectMax").value);	t2 = Math.max(document.getElementById("assignSelectMin").value, document.getElementById("assignSelectMax").value);	regionBegin = secToCanvasX(t1);	regionEnd   = secToCanvasX(t2);	displayBuffer(currentBuffer.getChannelData(0));	drawSelectedRegion(regionBegin, regionEnd);}function playBetween(startTime, endTime){	clearTimeout(timer); // 免除前一次 playBetween 設下的暫停影響	myAudio.playbackRate = 1.0;	myAudio.currentTime = startTime;	myAudio.play();	timer = setTimeout("myAudio.pause()", (endTime - startTime) * 1000); // 預約暫停}loadMusic('../pics/drift.mp3');lyrics = [[  1.0,  7.8, '片刻清醒片刻瘋狂　我醒在黑夜的海上'],[  7.8, 15.0, '乘著孤寂四處飄蕩　故鄉在遙遠的方向'],[ 15.0, 24.0, '緩緩登上一座荒島　這將是地獄或天堂'],[ 24.0, 31.0, '翠綠棕梠輕輕搖晃　帶給我生存的力量'],[ 31.0, 44.2, '忽然　看見　前方　有光　是誰　在唱'],[ 44.2, 56.0, '來吧　朋友　不要　沮喪　讓熱情驅逐哀傷'],[ 56.0, 62.9, '人生的海浪多無常　總是打擊人希望'],[ 62.9, 69.4, '前進的腳步雖踉蹌　揮揮手逝去淚光'],[ 69.4, 75.9, '多麼慶幸這一路上　有你陪在我身旁'],[ 75.9, 85.1, '總有一天　我們遠渡重洋'],[ 85.1, 93.0, '緩緩登上一座荒島　這將是地獄或天堂'],[ 93.0,100.0, '翠綠棕梠輕輕搖晃　帶給我生存的力量'],[100.0,112.3, '忽然　看見　前方　有光　是誰　在唱'],[112.3,125.0, '來吧　朋友　不要　沮喪　讓熱情驅逐哀傷'],[125.0,131.5, '人生的海浪多無常　總是打擊人希望'],[131.5,137.7, '前進的腳步雖踉蹌　揮揮手逝去淚光'],[137.7,144.3, '多麼慶幸這一路上　有你陪在我身旁'],[144.3,150.7, '總有一天　我們遠渡重洋'],[150.7,157.4, '再次回到　熟悉的故鄉']];for(i=0;i<lyrics.length;i++){	document.getElementById("showLyrics").innerHTML += `<a onclick="playBetween(  ${lyrics[i][0]},  ${lyrics[i][1]})">${lyrics[i][2]}</a><br/>`;}</script></body></html>