<html>
<head>
	<title>線上教材：Python 程式設計</title>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	<link rel=stylesheet type="text/css" href="myCss.css">
	<base target="_blank">
	<script type="text/javascript" src="shCore.js"></script>
	<script type="text/javascript" src="shBrushPython.js"></script>
	<link href="shCore.css" rel="stylesheet" type="text/css" />
	<link href="shThemeDefault.css" rel="stylesheet" type="text/css" />
	<script type="text/javascript">
		SyntaxHighlighter.all();
	</script>
</head>

<body bgcolor="#ccccff">

<blockquote>

<p>
Numpy 是 Python 的一個函式庫，支援了非常多種的向量和矩陣等等的運算，本篇將對部分功能進行重點式的介紹。要安裝 numpy，你必須先在 cmd 當中執行「pip install numpy」或「python -m pip install numpy」（根據系統設定的不同，可能在指令細節上會有些許差異）；安裝完成後，在 Python 程式中 import，就可以使用。
</p>

<p>首先來看一些基本的數學運算。由於常見的部分在 math 當中也有提供很多，故以下僅任意列出其中一些，作為語法的介紹：</p>
<pre class="brush: py">
import numpy as np

print(np.abs(-123.45))
print(np.log2(1024))
print(np.log10(2))
</pre>

<p>Numpy 當中，最基本與常見的資料結構，就是多維陣列(ndarray)；而向量，當然就是一維陣列：</p>
<pre class="brush: py">
import numpy as np

a = np.array([]) # 空陣列
b = np.array([3, 4, 2, 1, 5])
c = np.array([6, 8, 7, 5, 9])
print(b + c)
print(b - c)
print(b * c) # 元素對元素計算
print(b / c) # 元素對元素計算
print(a.shape, b.shape, c.shape)
</pre>

<p>創建規則向量，可以用 arange，相當於 range 的 numpy 版本；如果在你的程式中，知道點的個數比起知道幾點取一點來的方便的話，也可以使用 linspace：</p>
<pre class="brush: py">
import numpy as np

print(np.arange(10))
print(np.arange(1, 10))
print(np.arange(1, 10, 2))
print(np.linspace(0, 1, 11))
</pre>

<p>矩陣，也就是二維陣列，因此也就是很多個一維陣列排在一起：</p>
<pre class="brush: py">
import numpy as np

a = np.array([[1, 2, 3], [4, 5, 6]])

print(a)
print(a.shape)
</pre>

<p>Numpy 可以幫你創建各種具有某種規則的一維或二維陣列，以下介紹零矩陣和單位矩陣；如果你把 zeros 換成 ones，則可以產生全一矩陣：</p>
<pre class="brush: py">
import numpy as np

print(np.zeros(5))
print(np.zeros((2, 3)))
print(np.zeros((5, 1)))

print(np.eye(5))
print(np.eye(5, M=3))
</pre>

<p>Question: 如何產生全部都是某個任意實數的矩陣？</p>

<p>矩陣的合併則有各種「stack」系列的方法，或者「concatenate」可以使用。以下介紹其中兩種：</p>
<pre class="brush: py">
import numpy as np

a = np.array([[1, 2, 3], [4, 5, 6]])
b = np.array([[7, 8, 9], [0, 0, 0]])
print(a)
print(b)
print('=====')
print(np.vstack([a, b]))
print(np.hstack([a, b]))
</pre>

<p>需要注意的是，如果其中一方是空矩陣的話，可能會產生問題，所以必須對其 size 屬性進行判斷，例如下列程式片段中，已知 a 有可能為空時，可能會出問題的寫法，以及適當的對應方法如下：</p>
<pre class="brush: py">
a = np.array([])
b1 = np.array([1, 2, 3])
b2 = np.array([[1], [2], [3]])

c = np.hstack([a, b1])  # 空的一維向量接非空的一維向量，可以執行
c = np.vstack([b1, b1]) # 只是垂直疊兩個 b1，也可以執行
c = np.vstack([a, b1])  # 這行會產生錯誤
c = np.hstack([a, b2])  # 這行會產生錯誤

c = np.vstack([a, b1]) if(a.size) else b1
c = np.vstack([a, b2]) if(a.size) else b2
</pre>

<p>利用 Numpy 進行取極值、排序、平均的方法如下：</p>
<pre class="brush: py">
import numpy as np

a = np.array([[1, 5, 3], [4, 2, 6]])
print(np.max(a)) # 在所有元素裡面找
print(np.max(a, axis=0)) # 沿著 row index 的方向找
print(np.max(a, axis=1)) # 沿著 column index 的方向找

b = np.array([[4, 2, 5, 3, 1], [8, 6, 7, 9, 0]])
print(np.sort(b))         # 預設沿著最後一個軸(axis=-1)的方向排序
print(np.sort(b, axis=0)) # 沿著 row index 的方向排序

c = np.array([[4, 2, 5, 3, 1], [8, 6, 7, 9, 0]])
print(np.mean(c)) # 所有元素平均
print(np.mean(c, axis=0)) # 沿著 row index 的方向平均
print(np.mean(c, axis=1)) # 沿著 column index 的方向平均
</pre>

<p>你當然還可以進行更多比較複雜的統計運算，若有興趣請自行上網搜尋。而關於取極值或排序時，如果是需要找出位置或順序再做進一步利用時，可以使用 argmax 或 argsort（此處僅以向量示範）：</p>
<pre class="brush: py">
import numpy as np

a = np.array([4, 2, 3, 1, 5])
print(np.argmax(a))
print(np.argsort(a))
</pre>

<p>邏輯運算與尋找特定值的方法如下，此處亦僅以向量示範：</p>
<pre class="brush: py">
import numpy as np

a = np.array([4, 3, 1, 6, 9, 2, 5, 0, 8, 7])
print(a &gt;= 5)
print(np.where(a &gt;= 5)[0])

print(np.logical_or(a &gt;= 7, a &lt;= 3))
print(np.where(np.logical_or(a &gt;= 7, a &lt;= 3))[0])
</pre>

<p>矩陣的轉置，可以直接使用「.T」：</p>
<pre class="brush: py">
import numpy as np

a = np.array([[1, 5, 3], [4, 2, 6]])
print(a)
print(a.shape)
print(a.T)
print(a.T.shape)

print('------------')

b = np.array([[4], [2], [3]])
print(b)
print(b.shape)
print(b.T)
print(b.T.shape)

print('------------')

c = np.array([[4, 2, 3]])
print(c)
print(c.shape)
print(c.T)
print(c.T.shape)
</pre>

<p>但一維的向量若也需要轉置，則需要透過各種方法先變成二維。以下介紹將一維轉成二維的相關方法：</p>
<pre class="brush: py">
import numpy as np

a = np.array([4, 2, 3, 5, 1])
print(a)
print(a.shape)

print('------------')

b = a[np.newaxis, :]
print(b)
print(b.shape)

print('------------')

c = a[:, np.newaxis]
print(c)
print(c.shape)

print('------------')

d = a.reshape(a.shape[0], 1)
print(d)
print(d.shape)

print('------------')

e = a.reshape(a.shape[0], 1)
print(e)
print(e.shape)
</pre>

<!-- 
<p>矩陣相乘可以使用 matmul，若是元素對元素相乘，可以呼叫 multiply：</p>
<pre class="brush: py">
import numpy as np
 
a = np.array([[1,5,3], [4,2,6]])
b = np.array([[3,5,4,6,7], [8,2,4,7,1], [9,0,2,7,1]])
print(a)
print(b)
print(np.matmul(a, b))
 
print('------------')
 
c = np.array([[1,5,3], [4,2,6]])
d = np.array([[3,5,4], [9,0,2]])
print(c)
print(d)
print(np.multiply(c, d))
</pre>

<p>行列式值與反矩陣：</p>
<pre class="brush: py">
import numpy as np

a = np.array([[4,3,5], [2,6,1], [0,5,8]])
print(np.linalg.det(a))

print('------------')

b = np.linalg.inv(a)
print(b)
print(np.matmul(a,b)) # Should be very closed to identity
</pre>

<p>線性方程求解：</p>
<pre class="brush: py">
import numpy as np

A = np.array([[1,4,2], [3,1,8], [9,4,1]])
b = np.array([10, 11, 100])

# Ax = b
x, resid, rank, s = np.linalg.lstsq(A, b)
print(x)
print(np.matmul(A, x))

print('------------------')

# x'A = b
x, resid, rank, s = np.linalg.lstsq(A.T, b.T)
print(x)
print(np.matmul(x, A))
</pre>
 -->
</blockquote>

</body></html>
